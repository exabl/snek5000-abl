c-----------------------------------------------------------------------
c> @defgroup abl The ABL case user-file
c> Contains:
c>
c>  - user specified routines:
c>     - uservp  : variable properties
c>     - userf   : local acceleration term for fluid
c>     - userq   : local source term for scalars
c>     - userbc  : boundary conditions
c>     - useric  : initial conditions
c>     - userchk : general purpose routine for checking errors etc.
c>     - userqtl : thermal divergence for lowMach number flows
c>     - usrdat  : modify element vertices
c>     - usrdat2 : modify mesh coordinates
c>     - usrdat3 : general purpose routine for initialization
c>
c> @{
c----------------------------------------------------------------------
c drive flow with pressure gradient
#define DPDX uparam(3)
c define constant parameters
#define KAPPA 0.41
#define y0 0.0001
#define NPOW 0.5
#define C0 0.19
#define XLEN (2.*PI)
#define YLEN (1)
#define ZLEN PI

c> Set variable properties
c> @param ix x-index
c> @param iy y-index
c> @param iz z-index
c> @param ieg element index
      subroutine uservp(ix,iy,iz,ieg) ! set variable properties

c      implicit none


      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      integer ix,iy,iz,ieg,ie
      common /cdsmag/ ediff(lx1,ly1,lz1,lelv)
     $              , dg2 (lx1,ly1,lz1,lelv)


      ie     = gllel(ieg)
c     save total viscoity
      udiff  = ediff(ix,iy,iz,ie)


      utrans = 1.

      return
      end
c-----------------------------------------------------------------------
      subroutine userf(ix,iy,iz,eg) ! set acceleration term
c
c     Note: this is an acceleration term, NOT a force!
c     Thus, ffx will subsequently be multiplied by rho(x,t).
c
c      implicit none

      integer ix,iy,iz,eg

      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      common /cforce/ ffx_new,ffy_new,ffz_new

      integer e
c     e = gllel(eg)

      ffx = ffx_new ! This value determined from fixed U_b=1 case.
      ffy = 0.0
      ffz = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userq(ix,iy,iz,eg) ! set source term

c      implicit none

      integer ix,iy,iz,eg

      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

c      integer e
c     e = gllel(eg)
      source = 0.0
      qvol   = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc(ix,iy,iz,iside,eg) ! set up boundary conditions
c
c     NOTE ::: This subroutine MAY NOT be called by every process
c
c      implicit none


      integer ix,iy,iz,iside,eg,ie
      real u1_2,absu,y1_2

      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'


c      if (cbc(iside,gllel(eg),ifield).eq.'v01')


c--------Calculate Moeng's model parameters
       ie=gllel(eg)
       u1_2=(vx(ix,2,iz,ie)+vx(ix,1,iz,ie))/2
       w1_2=(vz(ix,2,iz,ie)+vz(ix,1,iz,ie))/2
       absu=sqrt(u1_2**2+w1_2**2)
       y1_2=(ym1(ix,2,iz,ie)+ym1(ix,1,iz,ie))/2


c--------Calculate Stresses
       trx = -KAPPA**2*(u1_2*absu)/(log(y1_2/y0)**2)
       try= 0.0
       trz= -KAPPA**2*(w1_2*absu)/(log(y1_2/y0)**2)
       temp = 0.0



      return
      end
c-----------------------------------------------------------------------
      subroutine useric(ix,iy,iz,eg) ! set up initial conditions

c      implicit none

      integer ix,iy,iz,eg
      real big,rand1,rand2,rand3

      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

c      ux   = 1.0
c      uy   = 0.0
c      uz   = 0.0
      temp = 0.0

      ie=gllel(eg)
      ux   = (0.0445/KAPPA)*log((ym1(ix,iy,iz,ie)+y0)/y0)

c     perturbation tries!! (not working)
      CALL RANDOM_NUMBER(rand1)
      CALL RANDOM_NUMBER(rand2)
      CALL RANDOM_NUMBER(rand3)
c      big = 1.e7*eg + 1.e8*ix + 1.e9*iy + 1.e10*iz
c      rand1 = sin(big)
c      rand2 = sin(rand1*big)
c      rand3 = sin(rand2*big)

      ux = ux*rand1
      uy = 1e-2*rand2
      uz = 1e-2*rand3

      eps = 1e-3
      kx  = 101
      kz  = 31

      alpha = kx * 2*PI
      beta  = kz * 2*PI

      ux  = ux  + eps*beta  * sin(alpha*x)*cos(beta*z)
      uy  = uy      eps       * sin(alpha*x)*sin(beta*z)
      uz  = uz     -eps*alpha * cos(alpha*x)*sin(beta*z)

      return
      end
c-----------------------------------------------------------------------
      subroutine userchk()

c      implicit none

      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'


      integer e,i
      real gradux(lx1,ly1,lz1,lelv)
      real graduy(lx1,ly1,lz1,lelv)
      real graduz(lx1,ly1,lz1,lelv)
      real vgrad(lx1,ly1,lz1,lelv)
      real x0(3),utau
      real utauv(lx1,ly1,lz1,lelv)
      save x0


c     call common blocks
      common /cdsmag/ ediff(lx1,ly1,lz1,lelv)
     $              , dg2 (lx1,ly1,lz1,lelv)

      common /scrsf/ trx(lx1,ly1,lz1)
     $             , trz(lx1,ly1,lz1)

      common /ctorq/ dragx(0:maxobj),dragpx(0:maxobj),dragvx(0:maxobj)
     $             , dragy(0:maxobj),dragpy(0:maxobj),dragvy(0:maxobj)
     $             , dragz(0:maxobj),dragpz(0:maxobj),dragvz(0:maxobj)
c
     $             , torqx(0:maxobj),torqpx(0:maxobj),torqvx(0:maxobj)
     $             , torqy(0:maxobj),torqpy(0:maxobj),torqvy(0:maxobj)
     $             , torqz(0:maxobj),torqpz(0:maxobj),torqvz(0:maxobj)
c
     $             , dpdx_mean,dpdy_mean,dpdz_mean
     $             , dgtq(3,4)

      common /cforce/ ffx_new,ffy_new,ffz_new

c     Define Delta for Smagorinsky method
      call set_grid_spacing(dg2)

      n=nx1*ny1*nz1*nelv
      ngll=nx1*ny1*nz1

c      calculate eddy viscosiy and total viscosity
      if(ifuservp) then
        if(nid.eq.0) write(6,*) 'Calculating eddy viscosity'
        do e=1,nelv
           call eddy_visc(e)
        enddo
        call copy(t,ediff,n)
      endif

      if (istep.eq.0) then
         call set_obj                   ! objects for surface integrals
         call rzero(x0,3)               ! torque w.r.t. x0
      endif

      ! driving force for Ubar = 1
      call set_forcing(ffx_new,vx,1)

      ! Calculate forces:
      call torque_calc(1.0,x0,.false.,.false.) ! wall shear

      rho    = 1.
      A_w    = XLEN * ZLEN

      ! Calculate friction velocity
      utau= sqrt(dragx(1)**2+dragz(1)**2)/A_w
      utau=sqrt(utau)

      !call gradients
      call gradm1(gradux,graduy,graduz,vx)

      !generate PHI statistic
      do i=1,n
	vgrad(i,1,1,1)=KAPPA*ym1(i,1,1,1)/utau*graduy(i,1,1,1)
	utauv(i,1,1,1)=utau
      enddo

      !Output new statistics
      if (mod(istep,iostep).eq.0)
     $ call outpost(dg2,vgrad,ediff,pr,t,'vgr')

      return
      end
c-----------------------------------------------------------------------
      subroutine userqtl ! Set thermal divergence

      call userqtl_scig

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat()   ! This routine to modify element vertices

c      implicit none

      include 'SIZE'
      include 'TOTAL'

      common /cdsmag/ ediff(lx1,ly1,lz1,lelv)
     $              , dg2 (lx1,ly1,lz1,lelv)

      ! initialize variables
      n = nx1*ny1*nz1*nelt
      call cfill(ediff,param(2),n)
      call cfill(dg2,1,n)


      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2()  ! This routine to modify mesh coordinates

c      implicit none

      include 'SIZE'
      include 'TOTAL'

      ! apply mass flux to drive the flow such that Ubar = 1
c       param(54) = -1   ! x-direction
c       param(55) = 1    ! Ubar

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3()

c      implicit none

      include 'SIZE'
      include 'TOTAL'

      return
      end
c-----------------------------------------------------------------------
      subroutine eddy_visc(e)
c
c     Compute eddy viscosity using dynamic smagorinsky model
c
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      common /cdsmag/ ediff(lx1,ly1,lz1,lelv)
     $              , dg2 (lx1,ly1,lz1,lelv)
      integer e
      common /dynsmg/ sij (lx1*ly1*lz1,ldim,ldim)
     $              , snrm(lx1*ly1*lz1,lelv)
     $              , Cs(lx1*ly1*lz1,lelv)
      real sij,snrm,Cs,Csa,Csb


      ntot = nx1*ny1*nz1
c------need to be by element ->
      call comp_gije(sij,vx(1,1,1,e),vy(1,1,1,e),vz(1,1,1,e),e)

      call comp_sije(sij)

      call mag_tensor_e(snrm(1,e),sij)
      call cmult(snrm(1,e),2.0,ntot)
c---------------------------

c------now do for every GLL point
      ntot = nx1*ny1*nz1*nelt
      if (e.eq.nelv) then
        do i=1,ntot
            Csa=1/(C0**NPOW)
            Csb=(sqrt(dg2(i,1,1,1))/(KAPPA*(ym1(i,1,1,1)+y0)))**NPOW
            Cs(i,1)=(Csa+Csb)**(-1/NPOW)
            ediff(i,1,1,1) = param(2)+Cs(i,1)*dg2(i,1,1,1)*snrm(i,1)
        enddo
      endif
c----------

      return
      end
c-----------------------------------------------------------------------

      subroutine set_grid_spacing(dg2)
c
c     Compute D^2, the grid spacing used in the DS sgs model.
c
      include 'SIZE'
      include 'TOTAL'


      real dg2(nx1,ny1,nz1,nelv)

      integer e,eg,ex,ey,ez

      gamma = 1.
      gamma = gamma/ndim

      n = nx1*ny1*nz1*nelv
      call rone(dg2,n)
 !     return               ! Comment this line for a non-trivial Delta defn

      do e=1,nelv

         do k=1,nz1
           km = max(1  ,k-1)
           kp = min(nz1,k+1)

           do j=1,ny1
             jm = max(1  ,j-1)
             jp = min(ny1,j+1)

             do i=1,nx1
               im = max(1  ,i-1)
               ip = min(nx1,i+1)

               di = (xm1(ip,j,k,e)-xm1(im,j,k,e))**2
     $            + (ym1(ip,j,k,e)-ym1(im,j,k,e))**2
     $            + (zm1(ip,j,k,e)-zm1(im,j,k,e))**2

               dj = (xm1(i,jp,k,e)-xm1(i,jm,k,e))**2
     $            + (ym1(i,jp,k,e)-ym1(i,jm,k,e))**2
     $            + (zm1(i,jp,k,e)-zm1(i,jm,k,e))**2

               dk = (xm1(i,j,kp,e)-xm1(i,j,km,e))**2
     $            + (ym1(i,j,kp,e)-ym1(i,j,km,e))**2
     $            + (zm1(i,j,kp,e)-zm1(i,j,km,e))**2
c               write(6,*) ip,im,jp,jm
               di = di/(ip-im)
               dj = dj/(jp-jm)
               dk = dk/(kp-km)
               dg2(i,j,k,e) = (di*dj*dk)**gamma

             enddo
           enddo
         enddo
      enddo

      call dsavg(dg2)  ! average neighboring elements

      return
      end
c-----------------------------------------------------------------------

      subroutine set_obj  ! define objects for surface integrals
c
      include 'SIZE'
      include 'TOTAL'
c
      integer e,f
c
c     Define new objects
c
      nobj = 1			! for Periodic
      iobj = 0

      do ii=nhis+1,nhis+nobj
         iobj = iobj+1
         hcode(10,ii) = 'I'
         hcode( 1,ii) = 'F' ! 'F'
         hcode( 2,ii) = 'F' ! 'F'
         hcode( 3,ii) = 'F' ! 'F'
         lochis(1,ii) = iobj
      enddo
      nhis = nhis + nobj

c
      if (maxobj.lt.nobj) write(6,*) 'increase maxobj in SIZEu. rm *.o'
      if (maxobj.lt.nobj) call exitt
c
      nxyz = nx1*ny1*nz1
      do e=1,nelv
      do f=1,2*ndim
         if (cbc(f,e,1).eq.'sh ') then
            iobj = 0
            if (f.eq.1) iobj=1  ! lower wall
            if (f.eq.3) iobj=2  ! upper wall
            if (iobj.gt.0) then
               nmember(iobj) = nmember(iobj) + 1
               mem = nmember(iobj)
               ieg = lglel(e)
               object(iobj,mem,1) = ieg
               object(iobj,mem,2) = f
            endif
c
         endif
      enddo
      enddo
c     write(6,*) 'number',(nmember(k),k=1,4)
c
      return
      end
c-----------------------------------
      subroutine set_forcing(f_new,u,idir)  ! driving force for Ubar = 1

      include 'SIZE'
      include 'TOTAL'

      common /uforce/ utldo(ldim)

      n=nx1*ny1*nz1*nelv

      if (istep.eq.0) then
         f_new = 0.
         if (DPDX.eq.1) then
            param(54) = -1 ! flow direction (x:1, y:2, z:3)
            param(55) = 1  ! flowrate (p54>) or Ubar (p54<0)
         endif
      endif

      if (DPDX.eq.1) return

      u_targ  = 1.
      ubar    = glsc2(u,bm1,n)/volvm1
      utilde  = ubar/u_targ

      if (istep.gt.0) f_new = 0.5 * (f_new + f_new/utilde)

      if (istep.gt.5) then
         alpha = abs(utilde-utldo(idir))/dt
         alpha = min(alpha,0.05)
         if     (utilde.gt.1.and.utilde.gt.utldo(idir)) then
            f_new = (1-alpha)*f_new
         elseif (utilde.lt.1.and.utilde.lt.utldo(idir)) then
            f_new = (1+alpha)*f_new
         endif
      endif
      utldo(idir)   = utilde

      f_min = 0.00001                 ! ad hoc limits
      f_new = max(f_new,f_min)

      f_max = 0.10000                 ! ad hoc limits
      f_new = min(f_new,f_max)

      return
      end

c> @}
c end of group abl
