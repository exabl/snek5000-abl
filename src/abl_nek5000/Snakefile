from glob import glob
import os
from pathlib import Path
from eturb.util import modification_date, now


configfile: "../../Snakeconfig.yml"

# Wildcard
FILES = glob_wildcards('{case}.usr').case


def tar_name():
    return 'archive-{timestamp}.tar.gz'.format(
            timestamp=max(
                modification_date(f) for f in ('compiler.out', 'SESSION.NAME')
            )
    )

subworkflow Nek5000:
    workdir:
        "../../lib/Nek5000"
    snakefile:
        "../../lib/Nek5000/Snakefile"
    configfile:
        "../../Snakeconfig.yml"

# default rule
rule all:
    input:
        'nek5000'

# shorthand for mesh
rule mesh:
    input:
        expand('{case}.re2', case=FILES),
        expand('{case}.ma2', case=FILES)

# compile
rule compile:
    input:
        expand('{case}.re2', case=FILES),
        expand('{case}.ma2', case=FILES)
    output:
        # temp('makefile'),
        'makefile',
        expand('{case}.f', case=FILES),
        'compiler.out',
        'nek5000'
    shell:
        'CC="{config[MPICC]}" FC="{config[MPIFC]}" CFLAGS="{config[CFLAGS]}" FFLAGS="{config[FFLAGS]}" '
        'makenek'

# run
rule run:
    input:
        'nek5000'
    params:
        logfile = "run_" + now() + ".log",
        nproc = str(os.cpu_count() // 2),
        case = expand("{case}", case=FILES)
    shell:
        """
        touch SESSION.NAME
        echo {params.case} > SESSION.NAME
        echo `pwd`'/' >>  SESSION.NAME
        {config[MPIEXEC]} -np {params.nproc} ./nek5000 > .snakemake/{params.logfile} &
        ln -sf .snakemake/{params.logfile} {params.case}.log
        """

# clean compiler output
rule clean:
    input: 'makefile',
    shell: 'echo "N" | makenek clean'

# clean simulation files
rule cleansimul:
    params:
        pattern = expand('*{case}?.f?????', case=FILES),
        tarball = tar_name()
    shell:
        """
        if [ ! -f {params.tarball} ]; then
            echo "ERROR: Archive {params.tarball} not found. Refusing to clean simulation files! Run 'snakemake archive'"
            exit 1
        fi
        set +e
        ls {params.pattern}
        rm -I -f {params.pattern}
        exit 0
        """

# clean everything
rule cleanall:
    shell:
        """
        snakemake clean cleansimul
        """

# create an archive with all of our results
# requires pigz - parallelized gzip
rule archive:
    input:
        *glob('3D_ABL0.f*'),
        *glob('vgr3D_ABL0.f*'),
        expand('{case}.usr', case=FILES),
        expand('{case}.par', case=FILES),
        expand('{case}.re2', case=FILES),
        expand('{case}.ma2', case=FILES),
        'SIZE',
        'compiler.out',
        'SESSION.NAME',
        'GIT_REVISION.txt'
    output:
        tarball=tar_name()
    shell:
        """
        tar --use-compress-program=pigz -cvf {output.tarball} {input}
        rm -f GIT_REVISION.txt
        """


# internal rules
# ==============
# generate a box mesh
rule generate_box:
    input:
        Nek5000('bin/genbox'),
        box=expand('{case}.box', case=FILES)
    output:
        'box.re2'
    shell:
        'echo {input.box} | '
        'genbox'

# rename mesh file re2
rule move_box:
    input: 'box.re2'
    output: expand('{case}.re2', case=FILES)
    shell:
        'mv -f {input} {output}'

# generate map / connectivity matrix
rule generate_map:
    input:
        Nek5000('bin/genmap'),
        expand('{case}.re2', case=FILES)
    output:
        expand('{case}.ma2', case=FILES)
    params:
        prefix = expand('{case}', case=FILES),
        tolerance = 0.01
    shell:
        'echo "{params.prefix}\n{params.tolerance}" | '
        'genmap'

# record git revision
rule git_rev:
    output: 'GIT_REVISION.txt'
    version: subprocess.getoutput('git rev-parse --short HEAD')
    shell:
        'printf {version} > GIT_REVISION.txt'
