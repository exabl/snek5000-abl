from glob import glob
from datetime import datetime
import os


# Wildcard
FILES = glob_wildcards('{case}.usr').case


# Functions used in rules
def isoformat(dt):
    return dt.isoformat(timespec="seconds").replace(':', '-')


def modification_date(path):
    """Modification date of a file or directory"""
    if os.path.exists(path):
        t = os.path.getmtime(path)
        return isoformat(datetime.fromtimestamp(t))
    else:
        return ''


def now():
    return isoformat(datetime.now())


def tar_name():
    return 'archive-{timestamp}.tar.gz'.format(
            timestamp=max(
                modification_date(f) for f in ('compiler.out', 'SESSION.NAME')
            )
    )

# default rule
rule all:
    input:
        'nek5000'

# shorthand for mesh
rule mesh:
    input:
        expand('{case}.re2', case=FILES),
        expand('{case}.ma2', case=FILES)

# compile
rule compile:
    input:
        expand('{case}.re2', case=FILES),
        expand('{case}.ma2', case=FILES)
    output:
        # temp('makefile'),
        'makefile',
        expand('{case}.f', case=FILES),
        'compiler.out',
        'nek5000'
    params:
        flags = "-mcmodel=medium -march=native"
    shell:
        'CFLAGS="{params.flags}" FFLAGS="{params.flags}" '
        'makenek'

# run
rule run:
    input:
        'nek5000'
    params:
        logfile = "run_" + now() + ".log",
        nproc = str(os.cpu_count()),
        case = expand("{case}", case=FILES)
    shell:
        """
        touch SESSION.NAME
        echo {params.case} > SESSION.NAME
        echo `pwd`'/' >>  SESSION.NAME
        mpiexec -np {params.nproc} ./nek5000 > .snakemake/{params.logfile} &
        ln -sf .snakemake/{params.logfile} {params.case}.log
        """

# clean compiler output
rule clean:
    input: 'makefile'
    shell: 'echo "N" | makenek clean'

# create an archive with all of our results
# requires pigz - parallelized gzip
rule archive:
    input:
        *glob('3D_ABL0.f*'),
        *glob('vgr3D_ABL0.f*'),
        expand('{case}.usr', case=FILES),
        expand('{case}.par', case=FILES),
        expand('{case}.re2', case=FILES),
        expand('{case}.ma2', case=FILES),
        'SIZE',
        'compiler.out',
        'SESSION.NAME',
        'GIT_REVISION.txt'
    output:
        tarball=tar_name()
    shell:
        """
        tar --use-compress-program=pigz -cvf {output.tarball} {input}
        rm -f GIT_REVISION.txt
        """


# internal rules
# ==============
# generate a box mesh
rule generate_box:
    input: expand('{case}.box', case=FILES)
    output: 'box.re2'
    shell:
        'echo {input} | '
        'genbox'

# rename mesh file re2
rule move_box:
    input: 'box.re2'
    output: expand('{case}.re2', case=FILES)
    shell:
        'mv -f {input} {output}'

# generate map / connectivity matrix
rule generate_map:
    input: expand('{case}.re2', case=FILES)
    output: expand('{case}.ma2', case=FILES)
    params:
        prefix = expand('{case}', case=FILES),
        tolerance = 0.01
    shell:
        'echo "{params.prefix}\n{params.tolerance}" | '
        'genmap'

# record git revision
rule git_rev:
    output: 'GIT_REVISION.txt'
    version: subprocess.getoutput('git rev-parse --short HEAD')
    shell:
        'printf {version} > GIT_REVISION.txt'
