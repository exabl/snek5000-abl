"""
Python package for managing case files.

User API
--------

- A path object :code:`abl.root` points to the directory containing the case files.

"""
import importlib.resources
import os
import pkgutil
import shutil
from pathlib import Path
from eturb.log import logger


# Better than
# root = Path(__file__).parent?
with importlib.resources.path(__name__, "__init__.py") as f:
    root = f.parent


def get_resources(pkg_name=__name__):
    """Get a generator of resources (files) in a package, excluding
    directories (subpackages).

    :returns: generator

    """
    blacklist = {"prefix": "__", "suffix": (".vimrc", ".tar.gz", ".o")}
    return (
        f
        for f in importlib.resources.contents(pkg_name)
        if (
            importlib.resources.is_resource(pkg_name, f)
            and not any(f.startswith(ext) for ext in blacklist["prefix"])
            and not any(f.endswith(ext) for ext in blacklist["suffix"])
        )
    )


def get_subpackages(pkg_name=__name__, pkg_path=__path__):
    """Get a dictionary of subpackages with values generated by
    :func:`get_resources`.

    :returns: dict

    """
    return {
        subpkg.name.lstrip(f"{root.name}."): get_resources(subpkg.name)
        for subpkg in pkgutil.walk_packages(pkg_path, prefix=f"{pkg_name}.")
    }


def get_paths():
    """Get a list of paths to all case files.

    :returns: list

    """
    paths = []

    # abl.usr -> /path/to/abl/abl.usr
    paths += [root / resource for resource in get_resources()]

    for subpkg, resources in get_subpackages().items():
        # toolbox -> /path/to/abl/toolbox
        subpkg_root = root / subpkg.replace(".", os.sep)
        # main.f -> /path/to/abl/toolbox/main.f
        paths += [subpkg_root / resource for resource in resources]
    return paths


def copy(new_dir, force=False):
    """Copy case files to a new directory. The directory does not have to be present.

    :param new_dir: A str or Path-like instance pointing to the new directory.
    :param force: Force copy would overwrite if files already exist.

    """
    abs_paths = get_paths()
    subpackages = get_subpackages()

    def conditional_ignore(src, names):
        """Ignore if not found in ``abs_paths``."""
        src = Path(src)
        include = abs_paths + [root / subpkg for subpkg in subpackages]
        exclude = tuple(
            name
            for name in names
            if not any((src / name) == path for path in include)
        )

        logger.debug(
            "".join(
                (
                    f"- src: {src}",
                    "\n- include:\n",
                    "\n ".join(str(name) for name in include),
                    "\n- exclude:\n",
                    "\n ".join(exclude),
                    "\n----",
                )
            )
        )
        return exclude

    new_root = Path(new_dir)
    try:
        logger.info("Copying with shutil.copytree ...")
        copytree_kwargs = dict(
            src=root, dst=new_root, symlinks=True, ignore=conditional_ignore,
        )
        # Python 3.8+
        shutil.copytree(
            **copytree_kwargs, dirs_exist_ok=True,
        )
    except TypeError:
        try:
            logger.warning(
                "Python < 3.8: shutil.copytree may not proceed if directories exist."
            )
            # Hoping that new_root has not been created
            shutil.copytree(**copytree_kwargs)
        except FileExistsError as e:
            logger.warning(e)
            logger.info("Copying with shutil.copy2 ...")
            # Copy one by one from the scratch
            if not new_root.exists():
                logger.debug(f"Creating {new_root} ...")
                os.makedirs(new_root, exist_ok=True)

            for abs_path in abs_paths:
                rel_path = abs_path.relative_to(root)
                new_path = new_root / rel_path
                if not new_path.parent.exists():
                    os.makedirs(new_path.parent)

                logger.debug(f"Copying {new_path}")
                if new_path.exists():
                    if force:
                        logger.warning(f"{new_path} would be overwritten ...")
                    else:
                        logger.warning(
                            f"{new_path} exists, skipping. Use force=True to overwrite."
                        )
                        continue

                shutil.copy2(abs_path, new_path)
    finally:
        logger.info(f"Copied: {root} -> {new_root}")
