"""
Python package for managing case files.


"""
import importlib.resources
import os
import pkgutil
import shutil
from pathlib import Path
from eturb.log import logger


class Case:
    """Container and methods for getting paths of and copying case files.

    A path object :code:`self.root` points to the directory containing the
    case files.

    """

    def __init__(self):
        # Same as package name __name__
        self.name = self.__module__

        # Better than
        # >>> root = Path(__file__).parent?
        with importlib.resources.path(self.name, "__init__.py") as f:
            self.root = f.parent

        self.blacklist = {"prefix": "__", "suffix": (".vimrc", ".tar.gz", ".o")}

    def _get_resources(self, pkg_name=None):
        """Get a generator of resources (files) in a package, excluding
        directories (subpackages).

        :returns: generator

        """
        blacklist = self.blacklist
        if not pkg_name:
            pkg_name = self.name
        return (
            f
            for f in importlib.resources.contents(pkg_name)
            if (
                importlib.resources.is_resource(pkg_name, f)
                and not any(f.startswith(ext) for ext in blacklist["prefix"])
                and not any(f.endswith(ext) for ext in blacklist["suffix"])
            )
        )

    def _get_subpackages(self):
        """Get a dictionary of subpackages with values generated by
        :func:`get_resources`.

        :returns: dict

        """
        pkg_path = self.root
        pkg_name = self.name
        return {
            subpkg.name.lstrip(f"{self.root.name}."): self._get_resources(
                subpkg.name
            )
            for subpkg in pkgutil.walk_packages(
                [str(pkg_path)], prefix=f"{pkg_name}."
            )
        }

    def get_paths(self):
        """Get a list of paths to all case files.

        :returns: list

        """
        paths = []

        # abl.usr -> /path/to/abl/abl.usr
        paths += [self.root / resource for resource in self._get_resources()]

        for subpkg, resources in self._get_subpackages().items():
            # toolbox -> /path/to/abl/toolbox
            subpkg_root = self.root / subpkg.replace(".", os.sep)
            # main.f -> /path/to/abl/toolbox/main.f
            paths += [subpkg_root / resource for resource in resources]
        return paths

    def copy(self, new_dir, force=False):
        """Copy case files to a new directory. The directory does not have to be present.

        :param new_dir: A str or Path-like instance pointing to the new directory.
        :param force: Force copy would overwrite if files already exist.

        """
        abs_paths = self.get_paths()
        subpackages = self._get_subpackages()
        root = self.root

        def conditional_ignore(src, names):
            """Ignore if not found in ``abs_paths``."""
            src = Path(src)
            include = abs_paths + [root / subpkg for subpkg in subpackages]
            exclude = tuple(
                name
                for name in names
                if not any((src / name) == path for path in include)
            )

            logger.debug(
                "".join(
                    (
                        f"- src: {src}",
                        "\n- include:\n",
                        "\n ".join(str(name) for name in include),
                        "\n- exclude:\n",
                        "\n ".join(exclude),
                        "\n----",
                    )
                )
            )
            return exclude

        new_root = Path(new_dir)
        try:
            logger.info("Copying with shutil.copytree ...")
            copytree_kwargs = dict(
                src=root, dst=new_root, symlinks=True, ignore=conditional_ignore,
            )
            # Python 3.8+
            shutil.copytree(
                **copytree_kwargs, dirs_exist_ok=True,
            )
        except TypeError:
            try:
                logger.warning(
                    "Python < 3.8: shutil.copytree may not proceed if directories exist."
                )
                # Hoping that new_root has not been created
                shutil.copytree(**copytree_kwargs)
            except FileExistsError as e:
                logger.warning(e)
                logger.info("Copying with shutil.copy2 ...")
                # Copy one by one from the scratch
                if not new_root.exists():
                    logger.debug(f"Creating {new_root} ...")
                    os.makedirs(new_root, exist_ok=True)

                for abs_path in abs_paths:
                    rel_path = abs_path.relative_to(root)
                    new_path = new_root / rel_path
                    if not new_path.parent.exists():
                        os.makedirs(new_path.parent)

                    logger.debug(f"Copying {new_path}")
                    if new_path.exists():
                        if force:
                            logger.warning(f"{new_path} would be overwritten ...")
                        else:
                            logger.warning(
                                f"{new_path} exists, skipping. Use force=True to overwrite."
                            )
                            continue

                    shutil.copy2(abs_path, new_path)
        finally:
            logger.info(f"Copied: {root} -> {new_root}")
