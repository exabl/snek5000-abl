c-----------------------------------------------------------------------
c> @defgroup abl The ABL case user-file
c> Contains: user specified routines for the ABL case
c>     - uservp  : variable properties
c>     - userf   : local acceleration term for fluid
c>     - userq   : local source term for scalars
c>     - userbc  : boundary conditions
c>     - useric  : initial conditions
c>     - userchk : general purpose routine for checking errors etc.
c>     - userqtl : thermal divergence for lowMach number flows
c>     - usrdat  : modify element vertices
c>     - usrdat2 : modify mesh coordinates
c>     - usrdat3 : general purpose routine for initialization
c>
c> @{
c----------------------------------------------------------------------
c drive flow with pressure gradient
#define DPDX uparam(3)
c define constant parameters
#define KAPPA 0.41
#define y0 0.1
#define NPOW 0.5
#define C0 0.19
#define U_GEO 5.0
#define PI (4.*atan(1.))

c> Set variable properties, does not call any subroutines / functions.
c> @param ix x-index
c> @param iy y-index
c> @param iz z-index
c> @param ieg element index
c> @todo implement ifield = 2 case for temperature
      subroutine uservp(ix,iy,iz,ieg) ! set variable properties

      implicit none

      include 'SIZE'
      include 'NEKUSE'  ! udiff, utrans
      include 'PARALLEL'  ! gllel
      include 'SGS'  ! ediff
      include 'TSTEP'  ! ifield

      integer ix,iy,iz,ieg,iel

      ! local element index
      iel = gllel(ieg)

      if (ifield.eq.1) then  ! velocity
        udiff = ediff(ix,iy,iz,iel)  ! dynamic viscosity
        utrans = 1.0  ! density
      else if (ifield.eq.2) then  ! temperature when IFHEAT = .true.
        udiff = 1.0  ! conductivity
        utrans = 1.0  ! rho*cp
      endif

      return
      end
c-----------------------------------------------------------------------
c
c> Compute Coriolis acceleration
c> \f[ F_x, F_z = - f\hat{e}_y \times \vec{u} \f]
c> See https://lists.mcs.anl.gov/pipermail/nek5000-users/2014-May/002798.html
c> @param[in]    ix,iy,iz        GLL point index
c> @param[in]    ieg             global element number
      subroutine userf(ix,iy,iz,eg) ! set acceleration term
c
c     Note: this is an acceleration term, NOT a force!
c     Thus, ffx will subsequently be multiplied by rho(x,t).
c
      implicit none

      include 'SIZE'
      include 'INPUT'           ! uparam
      include 'PARALLEL'        ! GLLEL
      include 'NEKUSE'            ! ffx, ffy, ffz, ux, uz

      ! argument list
      integer ix,iy,iz,eg

      ! local variables
      real f_corio

c     e = gllel(eg)

      f_corio = uparam(4)

      ffx = f_corio * uz
      ffy = 0.0
      ffz = -f_corio * (ux - U_GEO)

      return
      end
c-----------------------------------------------------------------------
      subroutine userq(ix,iy,iz,eg) ! set source term

      implicit none

      integer ix,iy,iz,eg

      include 'SIZE'
      include 'NEKUSE'  ! qvol

c      integer e
c     e = gllel(eg)
      ! source = 0.0
      qvol   = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc(ix,iy,iz,iside,eg) ! set up boundary conditions
c
c     NOTE ::: This subroutine MAY NOT be called by every process
c
      implicit none


      integer ix, iy, iz, iside, eg, ie
      real u1_2, w1_2, absu, y1_2

      include 'SIZE'
      include 'NEKUSE'  ! trx, try, trz, temp
      include 'PARALLEL'  ! gllel
      include 'SOLN'  ! vx, vz
      include 'GEOM'  ! ym1


c      if (cbc(iside,gllel(eg),ifield).eq.'v01')


c--------Calculate Moeng's model parameters
       ie=gllel(eg)
       u1_2=(vx(ix,2,iz,ie)+vx(ix,1,iz,ie))/2
       w1_2=(vz(ix,2,iz,ie)+vz(ix,1,iz,ie))/2
       absu=sqrt(u1_2**2+w1_2**2)
       y1_2=(ym1(ix,2,iz,ie)+ym1(ix,1,iz,ie))/2


c--------Calculate Stresses
       trx = -KAPPA**2*(u1_2*absu)/(log(y1_2/y0)**2)
       try= 0.0
       trz= -KAPPA**2*(w1_2*absu)/(log(y1_2/y0)**2)
       temp = 0.0



      return
      end
c-----------------------------------------------------------------------
c> Set up initial conditions
c> @callgraph
      subroutine useric(ix,iy,iz,eg)

      implicit none

      integer ix,iy,iz,eg,ie
      real Ly
      real rand1, rand2, rand3
      real eps, kx, kz, alpha, beta

      include 'SIZE'
      include 'NEKUSE'  ! temp
      include 'PARALLEL'  ! gllel
      include 'GEOM'  ! ym1
      include 'INPUT'  ! uparam

c      ux   = 1.0
c      uy   = 0.0
c      uz   = 0.0
      temp = 0.0

      ie=gllel(eg)
      ! NOTE: smoother function for ux and wavenumbers alpha and beta changed after
      ! version 0.2.1
      Ly = uparam(6)
      ux   = U_GEO * ((ym1(ix,iy,iz,ie) / Ly)**(1. / 7.))

c     perturbation tries!! (not working)
c> Use standard subroutine RANDOM_NUMBER.
c> See https://gcc.gnu.org/onlinedocs/gfortran/RANDOM_005fNUMBER.html
      CALL RANDOM_NUMBER(rand1)
      CALL RANDOM_NUMBER(rand2)
      CALL RANDOM_NUMBER(rand3)
c      big = 1.e7*eg + 1.e8*ix + 1.e9*iy + 1.e10*iz
c      rand1 = sin(big)
c      rand2 = sin(rand1*big)
c      rand3 = sin(rand2*big)

      ux = ux+0.001*rand1
      uy = 1e-3*rand2
      uz = 1e-3*rand3

      eps = 1e-3
      kx  = 11
      kz  = 11

      alpha = kx * 2*PI*40
      beta  = kz * 2*PI*40

      ux  = ux  + eps*beta  * sin(alpha*x)*cos(beta*z)
      uy  = uy  +   eps       * sin(alpha*x)*sin(beta*z)
      uz  = uz  -   eps*alpha * cos(alpha*x)*sin(beta*z)

      return
      end
c-----------------------------------------------------------------------
c> Compute the turbulent stress tensors and write statistics
c> @callgraph
      subroutine userchk()

      implicit none

      include 'SIZE'
      include 'GEOM'  ! ym1
      include 'INPUT'  ! IF3D, PARAM
      include 'SOLN'  ! t, pr, vx
      include 'TSTEP'  ! ISTEP, lastep, time
      include 'SGS'  ! dg2, ediff

      integer e,i
      real gradux(lx1,ly1,lz1,lelv)
      real graduy(lx1,ly1,lz1,lelv)
      real graduz(lx1,ly1,lz1,lelv)
      real vgrad(lx1,ly1,lz1,lelv)
      real x0(3),utau
      real utauv(lx1,ly1,lz1,lelv)
      save x0

      real XLEN, YLEN, ZLEN
c     call common blocks
!       common /scrsf/ trx(lx1,ly1,lz1)
!      $             , trz(lx1,ly1,lz1)

      integer n, ngll
      real A_w, rho
      real dpdx_mean, dpdy_mean, dpdz_mean, dgtq,
     $      dragx, dragpx, dragvx,
     $      dragy, dragpy, dragvy,
     $      dragz, dragpz, dragvz,
     $      torqx, torqpx, torqvx,
     $      torqy, torqpy, torqvy,
     $      torqz, torqpz, torqvz

      common /ctorq/ dragx(0:maxobj),dragpx(0:maxobj),dragvx(0:maxobj)
     $             , dragy(0:maxobj),dragpy(0:maxobj),dragvy(0:maxobj)
     $             , dragz(0:maxobj),dragpz(0:maxobj),dragvz(0:maxobj)
c
     $             , torqx(0:maxobj),torqpx(0:maxobj),torqvx(0:maxobj)
     $             , torqy(0:maxobj),torqpy(0:maxobj),torqvy(0:maxobj)
     $             , torqz(0:maxobj),torqpz(0:maxobj),torqvz(0:maxobj)
c
     $             , dpdx_mean,dpdy_mean,dpdz_mean
     $             , dgtq(3,4)

c     Get mesh lengths from userParam0{5,6,7}
      XLEN = uparam(5)
      YLEN = uparam(6)
      ZLEN = uparam(7)

c     Define Delta for Smagorinsky method
      call set_grid_spacing  ! set dg2

      n=nx1*ny1*nz1*nelv
      ngll=nx1*ny1*nz1

c      calculate eddy viscosiy and total viscosity
      if(ifuservp) then
        if(nid.eq.0) write(6,*) 'Calculating eddy viscosity'
        do e=1,nelv
           call eddy_visc(e, KAPPA, NPOW, y0)
        enddo
        call copy(t,ediff,n)
      endif

      if (istep.eq.0) then
         call set_obj                   ! objects for surface integrals
         call rzero(x0,3)               ! torque w.r.t. x0
      endif

      ! Calculate forces:
      call torque_calc(1.0,x0,.false.,.false.) ! wall shear

      rho    = 1.
      A_w    = XLEN * ZLEN  ! spanwise area

      ! Calculate friction velocity
      utau= sqrt(dragx(1)**2+dragz(1)**2)/A_w
      utau=sqrt(utau)

      !call gradients
      call gradm1(gradux,graduy,graduz,vx)

      !generate PHI statistic
      do i=1,n
        vgrad(i,1,1,1)=KAPPA * ym1(i,1,1,1) / utau*graduy(i,1,1,1)
        utauv(i,1,1,1)=utau
      enddo

      !Output new statistics
      if (mod(istep,iostep).eq.0)
     $ call outpost(dg2,vgrad,ediff,pr,t,'vgr')

      ! KTH toolbox related
      ! -------------------
      ! start framework
      if (ISTEP.eq.0) call frame_start

      ! monitor simulation
      call frame_monitor

      ! save/load files for full-restart
      call chkpt_main

      ! for tripping
      call stat_avg

      ! finalise framework
      if (ISTEP.eq.NSTEPS.or.LASTEP.eq.1) then
         call frame_end
      endif

      return
      end
c-----------------------------------------------------------------------
c> @callgraph
      subroutine userqtl ! Set thermal divergence

      implicit none

      call userqtl_scig

      return
      end
c-----------------------------------------------------------------------
c> @callgraph
      subroutine usrdat()   ! This routine to modify element vertices

      implicit none

      include 'SIZE'
      include 'INPUT'  ! param
      include 'SGS'  ! ediff, dg2

      integer n

      ! initialize variables
      n = nx1*ny1*nz1*nelt
      call cfill(ediff,param(2),n)
      call cfill(dg2,1.0,n)

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2()  ! This routine to modify mesh coordinates

      implicit none

      include 'SIZE'

      return
      end
c-----------------------------------------------------------------------
c> Compute inflow / outflow conditions a.k.a. driving force. Ubar=1
c> https://github.com/Nek5000/NekExamples/blob/70a5792b04b7a4c2da16463f517863b10627398f/turbChannel/turbChannel.usr#L375-L386
c> @callgrpah
      subroutine usrdat3()

      implicit none

      include 'SIZE'
      include 'INPUT'  ! param


      param(54) = -1  ! use >0 for const flowrate or <0 bulk vel
                      ! flow direction is given by (1=x, 2=y, 3=z)
      param(55) = U_GEO  ! flowrate/bulk-velocity

      return
      end
c-----------------------------------------------------------------------
c> Define objects for surface integrals
c> @callgraph
      subroutine set_obj

      implicit none
c
      include 'SIZE'
      include 'INPUT'  ! nhis, lochis, hcode
      include 'PARALLEL'  ! lglel
c
      integer e, f, ieg, ii, iobj, mem, nxyz
c
c     Define new objects
c
      nobj = 1  ! for Periodic
      iobj = 0

      do ii=nhis+1,nhis+nobj
         iobj = iobj+1
         hcode(10,ii) = 'I'
         hcode( 1,ii) = 'F' ! 'F'
         hcode( 2,ii) = 'F' ! 'F'
         hcode( 3,ii) = 'F' ! 'F'
         lochis(1,ii) = iobj
      enddo
      nhis = nhis + nobj

c
      if (maxobj.lt.nobj) write(6,*) 'increase maxobj in SIZEu. rm *.o'
      if (maxobj.lt.nobj) call exitt
c
      nxyz = nx1*ny1*nz1
      do e=1,nelv
        do f=1,2*ndim
         if (cbc(f,e,1).eq.'sh ') then
            iobj = 0
            if (f.eq.1) iobj=1  ! lower wall
            if (f.eq.3) iobj=2  ! upper wall
            if (iobj.gt.0) then
               nmember(iobj) = nmember(iobj) + 1
               mem = nmember(iobj)
               ieg = lglel(e)
               object(iobj,mem,1) = ieg
               object(iobj,mem,2) = f
            endif
c
         endif
        enddo
      enddo
c     write(6,*) 'number',(nmember(k),k=1,4)
c
      return
      end
c ----------------------------------------------------------------------
c> @}
c end of group abl
!======================================================================
c> @defgroup toolbox KTH Toolbox: user-file subroutines
c> @{
!> @brief Register user specified modules
      subroutine frame_usr_register
      implicit none

      include 'SIZE'
      include 'FRAMELP'
!-----------------------------------------------------------------------
!     register modules
      call io_register
      call chkpt_register
      call stat_register

      return
      end subroutine
!======================================================================
!> @brief Initialise user specified modules
      subroutine frame_usr_init
      implicit none

      include 'SIZE'
      include 'FRAMELP'
      include 'SOLN'
!-----------------------------------------------------------------------
!     initialise modules
      call chkpt_init
      call stat_init

      return
      end subroutine
!======================================================================
!> @brief Finalise user specified modules
      subroutine frame_usr_end
      implicit none

      include 'SIZE'
      include 'FRAMELP'
!-----------------------------------------------------------------------
!     finalise modules

      return
      end subroutine
!======================================================================
!======================================================================
!> @brief Provide element coordinates and local numbers (user interface)
!! @param[out]  idir              mapping (uniform) direction
!! @param[out]  ctrs              2D element centres
!! @param[out]  cell              local element numberring
!! @param[in]   lctrs1,lctrs2     array sizes
!! @param[out]  nelsort           number of local 3D elements to sort
!! @param[out]  map_xm1, map_ym1  2D coordinates of mapped elements
!! @param[out]  ierr              error flag
      subroutine user_map2d_get(idir,ctrs,cell,lctrs1,lctrs2,nelsort,
     $     map_xm1,map_ym1,ierr)
      implicit none

      include 'SIZE'
      include 'INPUT'           ! [XYZ]C
      include 'GEOM'            ! [XYZ]M1

!     argument list
      integer idir
      integer lctrs1,lctrs2
      real ctrs(lctrs1,lctrs2)  ! 2D element centres  and diagonals
      integer cell(lctrs2)      ! local element numberring
      integer nelsort           ! number of local 3D elements to sort
      real map_xm1(lx1,lz1,lelt), map_ym1(lx1,lz1,lelt)
      integer ierr              ! error flag

!     local variables
      integer ntot              ! tmp array size for copying
      integer el ,il ,jl        ! loop indexes
      integer nvert             ! vertex number
      real rnvert               ! 1/nvert
      real xmid,ymid            ! 2D element centre
      real xmin,xmax,ymin,ymax  ! to get approximate element diagonal
      integer ifc               ! face number

!     dummy arrays
      real xcoord(8,LELT), ycoord(8,LELT) ! tmp vertex coordinates

#ifdef DEBUG
!     for testing
      character*3 str1, str2
      integer iunit, ierrl
      ! call number
      integer icalldl
      save icalldl
      data icalldl /0/
#endif

!-----------------------------------------------------------------------
!     initial error flag
      ierr = 0
!     set important parameters
!     uniform direction; should be taken as input parameter
!     x-> 1, y-> 2, z-> 3
      idir = 3

!     get element midpoints
!     vertex number
      nvert = 2**NDIM
      rnvert= 1.0/real(nvert)

!     eliminate uniform direction
      ntot = 8*NELV
      if (idir.EQ.1) then  ! uniform X
         call copy(xcoord,YC,ntot) ! copy y
         call copy(ycoord,ZC,ntot) ! copy z
      elseif (idir.EQ.2) then  ! uniform Y
         call copy(xcoord,XC,ntot) ! copy x
         call copy(ycoord,ZC,ntot) ! copy z
      elseif (idir.EQ.3) then  ! uniform Z
         call copy(xcoord,XC,ntot) ! copy x
         call copy(ycoord,YC,ntot) ! copy y
      endif

!     set initial number of elements to sort
      nelsort = 0
      call izero(cell,NELT)

!     for every element
      do el=1,NELV
!     element centre
         xmid = xcoord(1,el)
         ymid = ycoord(1,el)
!     element diagonal
         xmin = xmid
         xmax = xmid
         ymin = ymid
         ymax = ymid
         do il=2,nvert
            xmid=xmid+xcoord(il,el)
            ymid=ymid+ycoord(il,el)
            xmin = min(xmin,xcoord(il,el))
            xmax = max(xmax,xcoord(il,el))
            ymin = min(ymin,ycoord(il,el))
            ymax = max(ymax,ycoord(il,el))
         enddo
         xmid = xmid*rnvert
         ymid = ymid*rnvert

!     count elements to sort
            nelsort = nelsort + 1
!     2D position
!     in general this coud involve some curvilinear transform
            ctrs(1,nelsort)=xmid
            ctrs(2,nelsort)=ymid
!     reference distance
            ctrs(3,nelsort)=sqrt((xmax-xmin)**2 + (ymax-ymin)**2)
            if (ctrs(3,nelsort).eq.0.0) then
               ierr = 1
               return
            endif
!     element index
            cell(nelsort) = el
      enddo

!     provide 2D mesh
!     in general this coud involve some curvilinear transform
      if (idir.EQ.1) then  ! uniform X
         ifc = 4
         do el=1,NELV
            call ftovec(map_xm1(1,1,el),ym1,el,ifc,nx1,ny1,nz1)
            call ftovec(map_ym1(1,1,el),zm1,el,ifc,nx1,ny1,nz1)
         enddo
      elseif (idir.eq.2) then  ! uniform y
         ifc = 1
         do el=1,nelv
            call ftovec(map_xm1(1,1,el),xm1,el,ifc,nx1,ny1,nz1)
            call ftovec(map_ym1(1,1,el),zm1,el,ifc,nx1,ny1,nz1)
         enddo
      elseif (idir.eq.3) then  ! uniform z
         ifc = 5
         do el=1,nelv
            call ftovec(map_xm1(1,1,el),xm1,el,ifc,nx1,ny1,nz1)
            call ftovec(map_ym1(1,1,el),ym1,el,ifc,nx1,ny1,nz1)
         enddo
      endif

#ifdef DEBUG
!     testing
      ! to output refinement
      icalldl = icalldl+1
      call io_file_freeid(iunit, ierrl)
      write(str1,'(i3.3)') NID
      write(str2,'(i3.3)') icalldl
      open(unit=iunit,file='map2d_usr.txt'//str1//'i'//str2)

      write(iunit,*) idir, NELV, nelsort
      write(iunit,*) 'Centre coordinates and cells'
      do el=1,nelsort
         write(iunit,*) el, ctrs(:,el), cell(el)
      enddo
      write(iunit,*) 'GLL coordinates'
      do el=1,nelsort
         write(iunit,*) 'Element ', el
         write(iunit,*) 'XM1'
         do il=1,nz1
            write(iunit,*) (map_xm1(jl,il,el),jl=1,nx1)
         enddo
         write(iunit,*) 'YM1'
         do il=1,nz1
            write(iunit,*) (map_ym1(jl,il,el),jl=1,nx1)
         enddo
      enddo
      close(iunit)
#endif

      return
      end subroutine
!=======================================================================
!> @brief Provide velocity, deriv. and vort. in required coordinates
!! @param[out]  lvel             velocity
!! @param[out]  dudx,dvdx,dwdx   velocity derivatives
!! @param[out]  vort             vorticity
      subroutine user_stat_trnsv(lvel,dudx,dvdx,dwdx,vort)
      implicit none

      include 'SIZE'
      include 'SOLN'
      include 'INPUT'               ! if3d

!     argument list
      real lvel(LX1,LY1,LZ1,LELT,3) ! velocity array
      real dudx(LX1,LY1,LZ1,LELT,3) ! velocity derivatives; U
      real dvdx(LX1,LY1,LZ1,LELT,3) ! V
      real dwdx(LX1,LY1,LZ1,LELT,3) ! W
      real vort(LX1,LY1,LZ1,LELT,3) ! vorticity

!     local variables
      integer itmp              ! dummy variable
!-----------------------------------------------------------------------
!     Velocity transformation; simple copy
      itmp = NX1*NY1*NZ1*NELV
      call copy(lvel(1,1,1,1,1),VX,itmp)
      call copy(lvel(1,1,1,1,2),VY,itmp)
      call copy(lvel(1,1,1,1,3),VZ,itmp)

!     Derivative transformation
!     No transformation
      call gradm1(dudx(1,1,1,1,1),dudx(1,1,1,1,2),dudx(1,1,1,1,3),
     $      lvel(1,1,1,1,1))
      call gradm1(dvdx(1,1,1,1,1),dvdx(1,1,1,1,2),dvdx(1,1,1,1,3),
     $      lvel(1,1,1,1,2))
      call gradm1(dwdx(1,1,1,1,1),dwdx(1,1,1,1,2),dwdx(1,1,1,1,3),
     $      lvel(1,1,1,1,3))

!     get vorticity
      if (IF3D) then
!     curlx
         call sub3(vort(1,1,1,1,1),dwdx(1,1,1,1,2),
     $        dvdx(1,1,1,1,3),itmp)
!     curly
         call sub3(vort(1,1,1,1,2),dudx(1,1,1,1,3),
     $        dwdx(1,1,1,1,1),itmp)
      endif
!     curlz
      call sub3(vort(1,1,1,1,3),dvdx(1,1,1,1,1),dudx(1,1,1,1,2),itmp)

      return
      end subroutine
!======================================================================
c> @}
c> @defgroup chkpoint KTH Toolbox: chkpoint
c> @defgroup chkpoint_mstep KTH Toolbox: chkpoint_mstep
c> @defgroup io_tools KTH Toolbox: io_tools
c> @defgroup math KTH Toolbox: math
c> @defgroup monitor KTH Toolbox: monitor
c> @defgroup runparam KTH Toolbox: runparam
c> @defgroup stat KTH Toolbox: stat
c vim: set ft=fortran
