c-----------------------------------------------------------------------
c> @defgroup abl The ABL case user-file
c> Contains: user specified routines for the ABL case
c>     - uservp  : variable properties
c>     - userf   : local acceleration term for fluid
c>     - userq   : local source term for scalars
c>     - userbc  : boundary conditions
c>     - useric  : initial conditions
c>     - userchk : general purpose routine for checking errors etc.
c>     - userqtl : thermal divergence for lowMach number flows
c>     - usrdat  : modify element vertices
c>     - usrdat2 : modify mesh coordinates
c>     - usrdat3 : general purpose routine for initialization
c>
c> @{
c----------------------------------------------------------------------
c drive flow with pressure gradient
#define DPDX uparam(3)
c define constant parameters
#define KAPPA 0.41
#define y0 0.0001
#define NPOW 0.5
#define C0 0.19

c> Set variable properties, does not call any subroutines / functions.
c> @param ix x-index
c> @param iy y-index
c> @param iz z-index
c> @param ieg element index
      subroutine uservp(ix,iy,iz,ieg) ! set variable properties

c      implicit none


      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      integer ix,iy,iz,ieg,ie
      common /cdsmag/ ediff(lx1,ly1,lz1,lelv)
     $              , dg2 (lx1,ly1,lz1,lelv)


      ie     = gllel(ieg)
c     save total viscoity
      udiff  = ediff(ix,iy,iz,ie)


      utrans = 1.

      return
      end
c-----------------------------------------------------------------------
c
      subroutine userf(ix,iy,iz,eg) ! set acceleration term
c
c     Note: this is an acceleration term, NOT a force!
c     Thus, ffx will subsequently be multiplied by rho(x,t).
c
c      implicit none

      integer ix,iy,iz,eg

      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      common /cforce/ ffx_new,ffy_new,ffz_new

      integer e
c     e = gllel(eg)

      ffx = ffx_new ! This value determined from fixed U_b=1 case.
      ffy = 0.0
      ffz = 0.0

      call coriolis(ffx, ffy, ffz, ix, iy, iz, eg)
      return
      end
c-----------------------------------------------------------------------
      subroutine userq(ix,iy,iz,eg) ! set source term

c      implicit none

      integer ix,iy,iz,eg

      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

c      integer e
c     e = gllel(eg)
      source = 0.0
      qvol   = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc(ix,iy,iz,iside,eg) ! set up boundary conditions
c
c     NOTE ::: This subroutine MAY NOT be called by every process
c
c      implicit none


      integer ix,iy,iz,iside,eg,ie
      real u1_2,absu,y1_2

      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'


c      if (cbc(iside,gllel(eg),ifield).eq.'v01')


c--------Calculate Moeng's model parameters
       ie=gllel(eg)
       u1_2=(vx(ix,2,iz,ie)+vx(ix,1,iz,ie))/2
       w1_2=(vz(ix,2,iz,ie)+vz(ix,1,iz,ie))/2
       absu=sqrt(u1_2**2+w1_2**2)
       y1_2=(ym1(ix,2,iz,ie)+ym1(ix,1,iz,ie))/2


c--------Calculate Stresses
       trx = -KAPPA**2*(u1_2*absu)/(log(y1_2/y0)**2)
       try= 0.0
       trz= -KAPPA**2*(w1_2*absu)/(log(y1_2/y0)**2)
       temp = 0.0



      return
      end
c-----------------------------------------------------------------------
c> Set up initial conditions
c> @callgraph
      subroutine useric(ix,iy,iz,eg)

c      implicit none

      integer ix,iy,iz,eg
      real big,rand1,rand2,rand3

      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

c      ux   = 1.0
c      uy   = 0.0
c      uz   = 0.0
      temp = 0.0

      ie=gllel(eg)
      ux   = (0.0445/KAPPA)*log((ym1(ix,iy,iz,ie)+y0)/y0)

c     perturbation tries!! (not working)
c> Use standard subroutine RANDOM_NUMBER.
c> See https://gcc.gnu.org/onlinedocs/gfortran/RANDOM_005fNUMBER.html
      CALL RANDOM_NUMBER(rand1)
      CALL RANDOM_NUMBER(rand2)
      CALL RANDOM_NUMBER(rand3)
c      big = 1.e7*eg + 1.e8*ix + 1.e9*iy + 1.e10*iz
c      rand1 = sin(big)
c      rand2 = sin(rand1*big)
c      rand3 = sin(rand2*big)

      ux = ux+0.01*rand1
      uy = 1e-2*rand2
      uz = 1e-2*rand3

      eps = 1e-3
      kx  = 101
      kz  = 31

      alpha = kx * 2*PI
      beta  = kz * 2*PI

      ux  = ux  + eps*beta  * sin(alpha*x)*cos(beta*z)
      uy  = uy  +   eps       * sin(alpha*x)*sin(beta*z)
      uz  = uz  -   eps*alpha * cos(alpha*x)*sin(beta*z)

      return
      end
c-----------------------------------------------------------------------
c> Compute the turbulent stress tensors and write statistics
c> @callgraph
      subroutine userchk()

c      implicit none

      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'
      ! The following are required by KTH toolbox, but it is already
      ! included in TOTAL
      ! include 'TSTEP'           ! ISTEP, lastep, time
      ! include 'INPUT'           ! IF3D, PARAM


      integer e,i
      real gradux(lx1,ly1,lz1,lelv)
      real graduy(lx1,ly1,lz1,lelv)
      real graduz(lx1,ly1,lz1,lelv)
      real vgrad(lx1,ly1,lz1,lelv)
      real x0(3),utau
      real utauv(lx1,ly1,lz1,lelv)
      save x0

      real XLEN, YLEN, ZLEN
c     call common blocks
      common /cdsmag/ ediff(lx1,ly1,lz1,lelv)
     $              , dg2 (lx1,ly1,lz1,lelv)

      common /scrsf/ trx(lx1,ly1,lz1)
     $             , trz(lx1,ly1,lz1)

      common /ctorq/ dragx(0:maxobj),dragpx(0:maxobj),dragvx(0:maxobj)
     $             , dragy(0:maxobj),dragpy(0:maxobj),dragvy(0:maxobj)
     $             , dragz(0:maxobj),dragpz(0:maxobj),dragvz(0:maxobj)
c
     $             , torqx(0:maxobj),torqpx(0:maxobj),torqvx(0:maxobj)
     $             , torqy(0:maxobj),torqpy(0:maxobj),torqvy(0:maxobj)
     $             , torqz(0:maxobj),torqpz(0:maxobj),torqvz(0:maxobj)
c
     $             , dpdx_mean,dpdy_mean,dpdz_mean
     $             , dgtq(3,4)

      common /cforce/ ffx_new,ffy_new,ffz_new

c     Get mesh lengths from userParam0{5,6,7}
      XLEN = uparam(5)
      YLEN = uparam(6)
      ZLEN = uparam(7)

c     Define Delta for Smagorinsky method
      call set_grid_spacing(dg2)

      n=nx1*ny1*nz1*nelv
      ngll=nx1*ny1*nz1

c      calculate eddy viscosiy and total viscosity
      if(ifuservp) then
        if(nid.eq.0) write(6,*) 'Calculating eddy viscosity'
        do e=1,nelv
           call eddy_visc(e)
        enddo
        call copy(t,ediff,n)
      endif

      if (istep.eq.0) then
         call set_obj                   ! objects for surface integrals
         call rzero(x0,3)               ! torque w.r.t. x0
      endif

      ! driving force for Ubar = 1
      call set_forcing(ffx_new,vx,1)

      ! Calculate forces:
      call torque_calc(1.0,x0,.false.,.false.) ! wall shear

      rho    = 1.
      A_w    = XLEN * ZLEN

      ! Calculate friction velocity
      utau= sqrt(dragx(1)**2+dragz(1)**2)/A_w
      utau=sqrt(utau)

      !call gradients
      call gradm1(gradux,graduy,graduz,vx)

      !generate PHI statistic
      do i=1,n
	vgrad(i,1,1,1)=KAPPA*ym1(i,1,1,1)/utau*graduy(i,1,1,1)
	utauv(i,1,1,1)=utau
      enddo

      !Output new statistics
      if (mod(istep,iostep).eq.0)
     $ call outpost(dg2,vgrad,ediff,pr,t,'vgr')

      ! KTH toolbox related
      ! -------------------
      ! start framework
      if (ISTEP.eq.0) call frame_start

      ! monitor simulation
      call frame_monitor

      ! save/load files for full-restart
      call chkpt_main

      ! for tripping
      call stat_avg

      ! finalise framework
      if (ISTEP.eq.NSTEPS.or.LASTEP.eq.1) then
         call frame_end
      endif

      return
      end
c-----------------------------------------------------------------------
c> @callgraph
      subroutine userqtl ! Set thermal divergence

      call userqtl_scig

      return
      end
c-----------------------------------------------------------------------
c> @callgraph
      subroutine usrdat()   ! This routine to modify element vertices

c      implicit none

      include 'SIZE'
      include 'TOTAL'

      common /cdsmag/ ediff(lx1,ly1,lz1,lelv)
     $              , dg2 (lx1,ly1,lz1,lelv)

      ! initialize variables
      n = nx1*ny1*nz1*nelt
      call cfill(ediff,param(2),n)
      call cfill(dg2,1,n)


      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2()  ! This routine to modify mesh coordinates

c      implicit none

      include 'SIZE'
      include 'TOTAL'

      ! apply mass flux to drive the flow such that Ubar = 1
c       param(54) = -1   ! x-direction
c       param(55) = 1    ! Ubar

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3()

c      implicit none

      include 'SIZE'
      include 'TOTAL'

      return
      end
c-----------------------------------------------------------------------
c> Compute eddy viscosity using dynamic smagorinsky model
c> @callgraph
      subroutine eddy_visc(e)
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      common /cdsmag/ ediff(lx1,ly1,lz1,lelv)
     $              , dg2 (lx1,ly1,lz1,lelv)
      integer e
      common /dynsmg/ sij (lx1*ly1*lz1,ldim,ldim)
     $              , snrm(lx1*ly1*lz1,lelv)
     $              , Cs(lx1*ly1*lz1,lelv)
      real sij,snrm,Cs,Csa,Csb


      ntot = nx1*ny1*nz1
c------need to be by element ->
      call comp_gije(sij,vx(1,1,1,e),vy(1,1,1,e),vz(1,1,1,e),e)

      call comp_sije(sij)

      call mag_tensor_e(snrm(1,e),sij)
      call cmult(snrm(1,e),2.0,ntot)
c---------------------------

c------now do for every GLL point
      ntot = nx1*ny1*nz1*nelt
      if (e.eq.nelv) then
        do i=1,ntot
            Csa=1/(C0**NPOW)
            Csb=(sqrt(dg2(i,1,1,1))/(KAPPA*(ym1(i,1,1,1)+y0)))**NPOW
            Cs(i,1)=(Csa+Csb)**(-1/NPOW)
          ediff(i,1,1,1) = param(2)+(Cs(i,1)**2)*dg2(i,1,1,1)*snrm(i,1)
        enddo
      endif
c----------

      return
      end
c-----------------------------------------------------------------------
c> Compute D^2, the grid spacing used in the DS sgs model.
c> @callgraph
      subroutine set_grid_spacing(dg2)
      include 'SIZE'
      include 'TOTAL'


      real dg2(nx1,ny1,nz1,nelv)

      integer e,eg,ex,ey,ez

      gamma = 1.
      gamma = gamma/ndim

      n = nx1*ny1*nz1*nelv
      call rone(dg2,n)
 !     return               ! Comment this line for a non-trivial Delta defn

      do e=1,nelv

         do k=1,nz1
           km = max(1  ,k-1)
           kp = min(nz1,k+1)

           do j=1,ny1
             jm = max(1  ,j-1)
             jp = min(ny1,j+1)

             do i=1,nx1
               im = max(1  ,i-1)
               ip = min(nx1,i+1)

               di = (xm1(ip,j,k,e)-xm1(im,j,k,e))**2
     $            + (ym1(ip,j,k,e)-ym1(im,j,k,e))**2
     $            + (zm1(ip,j,k,e)-zm1(im,j,k,e))**2

               dj = (xm1(i,jp,k,e)-xm1(i,jm,k,e))**2
     $            + (ym1(i,jp,k,e)-ym1(i,jm,k,e))**2
     $            + (zm1(i,jp,k,e)-zm1(i,jm,k,e))**2

               dk = (xm1(i,j,kp,e)-xm1(i,j,km,e))**2
     $            + (ym1(i,j,kp,e)-ym1(i,j,km,e))**2
     $            + (zm1(i,j,kp,e)-zm1(i,j,km,e))**2
c               write(6,*) ip,im,jp,jm
               di = di/(ip-im)
               dj = dj/(jp-jm)
               dk = dk/(kp-km)
               dg2(i,j,k,e) = (di*dj*dk)**gamma

             enddo
           enddo
         enddo
      enddo

      call dsavg(dg2)  ! average neighboring elements

      return
      end
c-----------------------------------------------------------------------
c> Define objects for surface integrals
c> @callgraph
      subroutine set_obj
c
      include 'SIZE'
      include 'TOTAL'
c
      integer e,f
c
c     Define new objects
c
      nobj = 1			! for Periodic
      iobj = 0

      do ii=nhis+1,nhis+nobj
         iobj = iobj+1
         hcode(10,ii) = 'I'
         hcode( 1,ii) = 'F' ! 'F'
         hcode( 2,ii) = 'F' ! 'F'
         hcode( 3,ii) = 'F' ! 'F'
         lochis(1,ii) = iobj
      enddo
      nhis = nhis + nobj

c
      if (maxobj.lt.nobj) write(6,*) 'increase maxobj in SIZEu. rm *.o'
      if (maxobj.lt.nobj) call exitt
c
      nxyz = nx1*ny1*nz1
      do e=1,nelv
      do f=1,2*ndim
         if (cbc(f,e,1).eq.'sh ') then
            iobj = 0
            if (f.eq.1) iobj=1  ! lower wall
            if (f.eq.3) iobj=2  ! upper wall
            if (iobj.gt.0) then
               nmember(iobj) = nmember(iobj) + 1
               mem = nmember(iobj)
               ieg = lglel(e)
               object(iobj,mem,1) = ieg
               object(iobj,mem,2) = f
            endif
c
         endif
      enddo
      enddo
c     write(6,*) 'number',(nmember(k),k=1,4)
c
      return
      end
c-----------------------------------
c> Compute inflow / outflow conditions a.k.a. driving force. Ubar=1
c> @callgraph
      subroutine set_forcing(f_new,u,idir)

      include 'SIZE'
      include 'TOTAL'

      common /uforce/ utldo(ldim)

      n=nx1*ny1*nz1*nelv

      if (istep.eq.0) then
         f_new = 0.
         if (DPDX.eq.1) then
            param(54) = -1 ! flow direction (x:1, y:2, z:3)
            param(55) = 1  ! flowrate (p54>) or Ubar (p54<0)
         endif
      endif

      if (DPDX.eq.1) return

      u_targ  = 1.
      ubar    = glsc2(u,bm1,n)/volvm1
      utilde  = ubar/u_targ

      if (istep.gt.0) f_new = 0.5 * (f_new + f_new/utilde)

      if (istep.gt.5) then
         alpha = abs(utilde-utldo(idir))/dt
         alpha = min(alpha,0.05)
         if     (utilde.gt.1.and.utilde.gt.utldo(idir)) then
            f_new = (1-alpha)*f_new
         elseif (utilde.lt.1.and.utilde.lt.utldo(idir)) then
            f_new = (1+alpha)*f_new
         endif
      endif
      utldo(idir)   = utilde

      f_min = 0.00001                 ! ad hoc limits
      f_new = max(f_new,f_min)

      f_max = 0.10000                 ! ad hoc limits
      f_new = min(f_new,f_max)

      return
      end

c ----------------------------------------------------------------------
c> Compute Coriolis acceleration
c> \f[ F_x, F_z = - f\hat{e}_y \times \vec{u} \f]
!! @param[inout] ffx,ffy,ffz     forcing; x,y,z component
!! @param[in]    ix,iy,iz        GLL point index
!! @param[in]    ieg             global element number
      subroutine coriolis(ffx,ffy,ffz,ix,iy,iz,ieg)
      implicit none
      include 'SIZE'            !
      include 'INPUT'           ! uparam
      include 'PARALLEL'        ! GLLEL
      include 'SOLN'            ! VX, VZ

      ! argument list
      real ffx, ffy, ffz
      integer ix,iy,iz,ieg

      ! local variables
      integer iel
      real f_corio
!-----------------------------------------------------------------------
      ! Local representation
      iel = gllel(ieg)
      f_corio = uparam(4)

      ! Add to forcing terms
      if (f_corio .gt. 0.) then
          ffx = ffx - f_corio * VZ(ix, iy, iz, iel)
          ffz = ffz + f_corio * VX(ix, iy, iz, iel)
      endif
      return
      end
c> @}
c end of group abl
!======================================================================
c> @defgroup toolbox KTH Toolbox: user-file subroutines
c> @{
!> @brief Register user specified modules
      subroutine frame_usr_register
      implicit none

      include 'SIZE'
      include 'FRAMELP'
!-----------------------------------------------------------------------
!     register modules
      call io_register
      call chkpt_register
      call stat_register

      return
      end subroutine
!======================================================================
!> @brief Initialise user specified modules
      subroutine frame_usr_init
      implicit none

      include 'SIZE'
      include 'FRAMELP'
      include 'SOLN'
!-----------------------------------------------------------------------
!     initialise modules
      call chkpt_init
      call stat_init

      return
      end subroutine
!======================================================================
!> @brief Finalise user specified modules
      subroutine frame_usr_end
      implicit none

      include 'SIZE'
      include 'FRAMELP'
!-----------------------------------------------------------------------
!     finalise modules

      return
      end subroutine
!======================================================================
!======================================================================
!> @brief Provide element coordinates and local numbers (user interface)
!! @param[out]  idir              mapping (uniform) direction
!! @param[out]  ctrs              2D element centres
!! @param[out]  cell              local element numberring
!! @param[in]   lctrs1,lctrs2     array sizes
!! @param[out]  nelsort           number of local 3D elements to sort
!! @param[out]  map_xm1, map_ym1  2D coordinates of mapped elements
!! @param[out]  ierr              error flag
      subroutine user_map2d_get(idir,ctrs,cell,lctrs1,lctrs2,nelsort,
     $     map_xm1,map_ym1,ierr)
      implicit none

      include 'SIZE'
      include 'INPUT'           ! [XYZ]C
      include 'GEOM'            ! [XYZ]M1

!     argument list
      integer idir
      integer lctrs1,lctrs2
      real ctrs(lctrs1,lctrs2)  ! 2D element centres  and diagonals
      integer cell(lctrs2)      ! local element numberring
      integer nelsort           ! number of local 3D elements to sort
      real map_xm1(lx1,lz1,lelt), map_ym1(lx1,lz1,lelt)
      integer ierr              ! error flag

!     local variables
      integer ntot              ! tmp array size for copying
      integer el ,il ,jl        ! loop indexes
      integer nvert             ! vertex number
      real rnvert               ! 1/nvert
      real xmid,ymid            ! 2D element centre
      real xmin,xmax,ymin,ymax  ! to get approximate element diagonal
      integer ifc               ! face number

!     dummy arrays
      real xcoord(8,LELT), ycoord(8,LELT) ! tmp vertex coordinates

#ifdef DEBUG
!     for testing
      character*3 str1, str2
      integer iunit, ierrl
      ! call number
      integer icalldl
      save icalldl
      data icalldl /0/
#endif

!-----------------------------------------------------------------------
!     initial error flag
      ierr = 0
!     set important parameters
!     uniform direction; should be taken as input parameter
!     x-> 1, y-> 2, z-> 3
      idir = 3

!     get element midpoints
!     vertex number
      nvert = 2**NDIM
      rnvert= 1.0/real(nvert)

!     eliminate uniform direction
      ntot = 8*NELV
      if (idir.EQ.1) then  ! uniform X
         call copy(xcoord,YC,ntot) ! copy y
         call copy(ycoord,ZC,ntot) ! copy z
      elseif (idir.EQ.2) then  ! uniform Y
         call copy(xcoord,XC,ntot) ! copy x
         call copy(ycoord,ZC,ntot) ! copy z
      elseif (idir.EQ.3) then  ! uniform Z
         call copy(xcoord,XC,ntot) ! copy x
         call copy(ycoord,YC,ntot) ! copy y
      endif

!     set initial number of elements to sort
      nelsort = 0
      call izero(cell,NELT)

!     for every element
      do el=1,NELV
!     element centre
         xmid = xcoord(1,el)
         ymid = ycoord(1,el)
!     element diagonal
         xmin = xmid
         xmax = xmid
         ymin = ymid
         ymax = ymid
         do il=2,nvert
            xmid=xmid+xcoord(il,el)
            ymid=ymid+ycoord(il,el)
            xmin = min(xmin,xcoord(il,el))
            xmax = max(xmax,xcoord(il,el))
            ymin = min(ymin,ycoord(il,el))
            ymax = max(ymax,ycoord(il,el))
         enddo
         xmid = xmid*rnvert
         ymid = ymid*rnvert

!     count elements to sort
            nelsort = nelsort + 1
!     2D position
!     in general this coud involve some curvilinear transform
            ctrs(1,nelsort)=xmid
            ctrs(2,nelsort)=ymid
!     reference distance
            ctrs(3,nelsort)=sqrt((xmax-xmin)**2 + (ymax-ymin)**2)
            if (ctrs(3,nelsort).eq.0.0) then
               ierr = 1
               return
            endif
!     element index
            cell(nelsort) = el
      enddo

!     provide 2D mesh
!     in general this coud involve some curvilinear transform
      if (idir.EQ.1) then  ! uniform X
         ifc = 4
         do el=1,NELV
            call ftovec(map_xm1(1,1,el),ym1,el,ifc,nx1,ny1,nz1)
            call ftovec(map_ym1(1,1,el),zm1,el,ifc,nx1,ny1,nz1)
         enddo
      elseif (idir.eq.2) then  ! uniform y
         ifc = 1
         do el=1,nelv
            call ftovec(map_xm1(1,1,el),xm1,el,ifc,nx1,ny1,nz1)
            call ftovec(map_ym1(1,1,el),zm1,el,ifc,nx1,ny1,nz1)
         enddo
      elseif (idir.eq.3) then  ! uniform z
         ifc = 5
         do el=1,nelv
            call ftovec(map_xm1(1,1,el),xm1,el,ifc,nx1,ny1,nz1)
            call ftovec(map_ym1(1,1,el),ym1,el,ifc,nx1,ny1,nz1)
         enddo
      endif

#ifdef DEBUG
!     testing
      ! to output refinement
      icalldl = icalldl+1
      call io_file_freeid(iunit, ierrl)
      write(str1,'(i3.3)') NID
      write(str2,'(i3.3)') icalldl
      open(unit=iunit,file='map2d_usr.txt'//str1//'i'//str2)

      write(iunit,*) idir, NELV, nelsort
      write(iunit,*) 'Centre coordinates and cells'
      do el=1,nelsort
         write(iunit,*) el, ctrs(:,el), cell(el)
      enddo
      write(iunit,*) 'GLL coordinates'
      do el=1,nelsort
         write(iunit,*) 'Element ', el
         write(iunit,*) 'XM1'
         do il=1,nz1
            write(iunit,*) (map_xm1(jl,il,el),jl=1,nx1)
         enddo
         write(iunit,*) 'YM1'
         do il=1,nz1
            write(iunit,*) (map_ym1(jl,il,el),jl=1,nx1)
         enddo
      enddo
      close(iunit)
#endif

      return
      end subroutine
!=======================================================================
!> @brief Provide velocity, deriv. and vort. in required coordinates
!! @param[out]  lvel             velocity
!! @param[out]  dudx,dvdx,dwdx   velocity derivatives
!! @param[out]  vort             vorticity
      subroutine user_stat_trnsv(lvel,dudx,dvdx,dwdx,vort)
      implicit none

      include 'SIZE'
      include 'SOLN'
      include 'INPUT'               ! if3d

!     argument list
      real lvel(LX1,LY1,LZ1,LELT,3) ! velocity array
      real dudx(LX1,LY1,LZ1,LELT,3) ! velocity derivatives; U
      real dvdx(LX1,LY1,LZ1,LELT,3) ! V
      real dwdx(LX1,LY1,LZ1,LELT,3) ! W
      real vort(LX1,LY1,LZ1,LELT,3) ! vorticity

!     local variables
      integer itmp              ! dummy variable
!-----------------------------------------------------------------------
!     Velocity transformation; simple copy
      itmp = NX1*NY1*NZ1*NELV
      call copy(lvel(1,1,1,1,1),VX,itmp)
      call copy(lvel(1,1,1,1,2),VY,itmp)
      call copy(lvel(1,1,1,1,3),VZ,itmp)

!     Derivative transformation
!     No transformation
      call gradm1(dudx(1,1,1,1,1),dudx(1,1,1,1,2),dudx(1,1,1,1,3),
     $      lvel(1,1,1,1,1))
      call gradm1(dvdx(1,1,1,1,1),dvdx(1,1,1,1,2),dvdx(1,1,1,1,3),
     $      lvel(1,1,1,1,2))
      call gradm1(dwdx(1,1,1,1,1),dwdx(1,1,1,1,2),dwdx(1,1,1,1,3),
     $      lvel(1,1,1,1,3))

!     get vorticity
      if (IF3D) then
!     curlx
         call sub3(vort(1,1,1,1,1),dwdx(1,1,1,1,2),
     $        dvdx(1,1,1,1,3),itmp)
!     curly
         call sub3(vort(1,1,1,1,2),dudx(1,1,1,1,3),
     $        dwdx(1,1,1,1,1),itmp)
      endif
!     curlz
      call sub3(vort(1,1,1,1,3),dvdx(1,1,1,1,1),dudx(1,1,1,1,2),itmp)

      return
      end subroutine
!======================================================================
c> @}
c> @defgroup chkpoint KTH Toolbox: chkpoint
c> @defgroup chkpoint_mstep KTH Toolbox: chkpoint_mstep
c> @defgroup io_tools KTH Toolbox: io_tools
c> @defgroup math KTH Toolbox: math
c> @defgroup monitor KTH Toolbox: monitor
c> @defgroup runparam KTH Toolbox: runparam
c> @defgroup stat KTH Toolbox: stat
