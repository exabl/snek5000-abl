import importlib.resources
import itertools
import os
from glob import iglob
from pathlib import Path
from socket import gethostname

import snek5000
from abl.output import OutputABL as Output
from snek5000.util import now
from snek5000.util.archive import tar_name, archive, clean_simul


# Case name
CASE = "abl"
CONFIG = Output.get_configfile()
ROOT = Output.get_root()
SOURCE_ROOT = snek5000.source_root()


# TODO: define configuration files for SNIC clusters
configfile: CONFIG

if os.getenv("SNEK_DEBUG"):
    config["CFLAGS"] += " -O0 -g"
    config["FFLAGS"] += " -O0 -g -ffpe-trap=invalid,zero,overflow,underflow -Wall"

if not os.getenv("SOURCE_ROOT"):
    os.environ["SOURCE_ROOT"] = SOURCE_ROOT

if SOURCE_ROOT not in os.getenv("PATH"):
    os.environ["PATH"] = ":".join([SOURCE_ROOT, os.getenv("PATH")])


subworkflow Nek5000:
    workdir: SOURCE_ROOT
    snakefile: snek5000.get_asset('nek5000.smk')
    configfile: CONFIG

# default rule
rule all:
    input:
        'nek5000'

# shorthand for mesh
rule mesh:
    input: f"{CASE}.re2", f"{CASE}.ma2"

# compile
rule compile:
    input:
        'makefile_usr.inc',
        'makefile',
        SOURCE_ROOT + "/3rd_party/gslib/lib/libgs.a"
    output:
        f'{CASE}.f',
        exe='nek5000'
    shell:
        'make -j {output.exe}'

# run
rule run:
    input:
        f'{CASE}.re2',
        f'{CASE}.ma2',
        f'{CASE}.par',
        'SESSION.NAME',
        'nek5000'
    log:
        "logs/run_" + now() + ".log"
    params:
        nproc = str(os.cpu_count()),
        case = f"{CASE}"
    shell:
        """
        ln -sf {log} {params.case}.log
        echo "Log file: $PWD"/{params.case}.log
        {config[MPIEXEC]} -n {params.nproc} ./nek5000 > {log} &
        """

# on cluster
rule srun:
    input:
        f'{CASE}.re2',
        f'{CASE}.ma2',
        f'{CASE}.par',
        'SESSION.NAME',
        'nek5000'
    log:
        "logs/run_" + now() + ".log"
    params:
        nproc = str(os.cpu_count()),
        case = f"{CASE}"
    shell:
        """
        ln -sf {log} {params.case}.log
        echo "Log file: $PWD"/{params.case}.log
        {config[MPIEXEC]} -n {params.nproc} ./nek5000 | tee {log}
        """

# clean compiler output
rule clean:
    params:
        case = f'{CASE}',
    shell:
        """
        echo "cleaning Nek5000 ..."
        rm -fv {params.case}.f nek5000
        rm -fv $SOURCE_ROOT/core/mpif.h
        """

# clean simulation files
rule cleansimul:
    params:
        case = f'{CASE}',
        tarball = tar_name(compress_format=".zst")
    run:
        clean_simul(params.case, params.tarball)

# clean everything
rule cleanall:
    shell:
        """
        rm -rf obj makefile_usr.inc
        snakemake clean cleansimul -j
        """

# create an archive with all of our results
rule archive:
    params:
        solution = sorted(
            itertools.chain.from_iterable(
                (
                    iglob(f'{prefix}{CASE}0.f*')
                    for prefix in ("", "vgr", "c2D", "sts")
                )
            )
        ),
        rest = [
            'SESSION.NAME',
            'params.xml',
            'SIZE',
            *iglob(f'rs6{CASE}0.f*'),
            f'{CASE}.re2',
            f'{CASE}.ma2',
            f'{CASE}.par',
            f'{CASE}.usr',
        ],
        tarball = tar_name()
    run:
        archive(params.tarball, params.solution, remove=True)
        archive(params.tarball, params.rest)
        archive(params.tarball + ".zst", readonly=True)


# internal rules
# ==============
# generate a box mesh
rule generate_box:
    input:
        box = f'{CASE}.box',
        genbox = Nek5000('bin/genbox')
    output:
        'box.re2'
    shell:
        'echo {input.box} | '
        '{input.genbox}'

# rename mesh file re2
rule move_box:
    input: 'box.re2'
    output: f'{CASE}.re2'
    shell:
        'mv -f {input} {output}'

# generate map / connectivity matrix
rule generate_map:
    input:
        f'{CASE}.re2',
        genmap = Nek5000('bin/genmap')
    output:
        f'{CASE}.ma2'
    params:
        prefix = f'{CASE}',
        tolerance = 0.01
    shell:
        'echo "{params.prefix}\n{params.tolerance}" | '
        '{input.genmap}'

# generate makefile
rule generate_makefile:
    input:
        f'{CASE}.re2',
        f'{CASE}.ma2',
        f'{CASE}.usr',
        makenek = SOURCE_ROOT + "/bin/makenek"
    output:
        'makefile',
        SOURCE_ROOT + "/3rd_party/gslib/lib/libgs.a"
    params:
        case = f'{CASE}',
        inc = " ".join((f"-I{inc_dir}" for inc_dir in Output().makefile_usr_sources)),
        usr = " ".join(Output().makefile_usr_obj)
    shell:
        """
        function at_exit {{
            ls -l makefile
            export NOCOMPILE=0
            clean_3rd_party
            make_3rd_party
            echo "Done"
        }}
        trap at_exit EXIT

        set +u  # Do not error on undefined bash variables
        export CC="{config[MPICC]}" FC="{config[MPIFC]}" \
            CFLAGS="{config[CFLAGS]}" FFLAGS="{config[FFLAGS]} {params.inc}" \
            USR="{params.usr}"
        source {input.makenek} {params.case} -nocompile
        """

# generate sessionfile
rule generate_session:
    output:
        "SESSION.NAME"
    params:
        case = f"{CASE}"
    shell:
        """
        touch SESSION.NAME
        echo {params.case} > SESSION.NAME
        echo `pwd`'/' >>  SESSION.NAME
        """
