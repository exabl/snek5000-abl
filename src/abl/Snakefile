import itertools
import os
from glob import iglob
from pathlib import Path
from socket import gethostname

from abl import (
    get_configfile,
    get_root,
    makefile_usr_sources,
    makefile_usr_obj,
    Output
)
from eturb.util import now
from eturb.util.archive import tar_name, archive, clean_simul


# Case name
CASE = "abl"
CONFIG = get_configfile()
ROOT = get_root()
SOURCE_ROOT = os.getenv("SOURCE_ROOT", str(ROOT / "../../lib/Nek5000"))

# TODO: define configuration files for SNIC clusters
configfile: CONFIG

if os.getenv("ETURB_DEBUG"):
    config["CFLAGS"] += " -O0 -g"
    config["FFLAGS"] += " -O0 -g -ffpe-trap=invalid,zero,overflow,underflow"


subworkflow Nek5000:
    workdir: SOURCE_ROOT
    snakefile: SOURCE_ROOT + "/Snakefile"
    configfile: CONFIG

# default rule
rule all:
    input:
        'nek5000'

# shorthand for mesh
rule mesh:
    input: f"{CASE}.re2", f"{CASE}.ma2"

# compile
rule compile:
    input:
        'makefile_usr.inc',
        'makefile'
        #  SOURCE_ROOT + "/3rd_party/gslib/lib/libgs.a"
    output:
        f'{CASE}.f',
        exe='nek5000'
    shell:
        'make -j {output.exe}'

# run
rule run:
    input:
        f'{CASE}.re2',
        f'{CASE}.ma2',
        f'{CASE}.par',
        'SESSION.NAME',
        'nek5000'
    log:
        "logs/run_" + now() + ".log"
    params:
        nproc = str(os.cpu_count()),
        case = f"{CASE}"
    shell:
        """
        {config[MPIEXEC]} -n {params.nproc} ./nek5000 > {log} &
        ln -sf {log} {params.case}.log
        echo "Log file: $PWD"/{params.case}.log
        """

# on cluster
rule srun:
    input:
        f'{CASE}.re2',
        f'{CASE}.ma2',
        f'{CASE}.par',
        'SESSION.NAME',
        'nek5000'
    params:
        nproc = str(os.cpu_count()),
    shell:
        '{config[MPIEXEC]} -n {params.nproc} ./nek5000'

# clean compiler output
rule clean:
    params:
        case = f'{CASE}',
    shell:
        """
        echo "cleaning Nek5000 ..."
        rm -fv {params.case}.f nek5000
        rm -rf obj makefile_usr.inc
        rm -fv $SOURCE_ROOT/core/mpif.h
        """

# clean simulation files
rule cleansimul:
    params:
        case = f'{CASE}',
        tarball = tar_name(compress_format=".zst")
    run:
        clean_simul(params.case, params.tarball)

# clean everything
rule cleanall:
    shell:
        """
        snakemake clean cleansimul
        """

# create an archive with all of our results
rule archive:
    params:
        solution = sorted(
            itertools.chain.from_iterable(
                (
                    iglob(f'{prefix}{CASE}0.f*')
                    for prefix in ("", "vgr", "c2D", "sts")
                )
            )
        ),
        rest = [
            'SESSION.NAME',
            'params.xml',
            'SIZE',
            *iglob(f'rs6{CASE}0.f*'),
            f'{CASE}.re2',
            f'{CASE}.ma2',
            f'{CASE}.par',
            f'{CASE}.usr',
        ],
        tarball = tar_name()
    # FIXME
    # output: protected(tar_name())
    run:
        archive(params.tarball, params.solution, remove=True)
        archive(params.tarball, params.rest)
        archive(params.tarball + ".zst", readonly=True)


# internal rules
# ==============
# generate a box mesh
rule generate_box:
    input:
        Nek5000('bin/genbox'),
        box=f'{CASE}.box'
    output:
        'box.re2'
    shell:
        'echo {input.box} | '
        'genbox'

# rename mesh file re2
rule move_box:
    input: 'box.re2'
    output: f'{CASE}.re2'
    shell:
        'mv -f {input} {output}'

# generate map / connectivity matrix
rule generate_map:
    input:
        Nek5000('bin/genmap'),
        f'{CASE}.re2'
    output:
        f'{CASE}.ma2'
    params:
        prefix = f'{CASE}',
        tolerance = 0.01
    shell:
        'echo "{params.prefix}\n{params.tolerance}" | '
        'genmap'

# generate makefile_usr.inc
rule generate_makefile_usr:
    input:
        "templates/makefile_usr.inc.j2"
    output:
        "makefile_usr.inc"
    run:
        o = Output()
        with open(str(output), "w") as fp:
            o.write_makefile_usr(fp=fp)

# generate makefile
rule generate_makefile:
    input:
        f'{CASE}.re2',
        f'{CASE}.ma2',
        f'{CASE}.usr',
        makefile_usr = "makefile_usr.inc"
    output:
        'makefile'
    params:
        case = f'{CASE}',
        inc = " ".join((f"-I{inc_dir}" for inc_dir in makefile_usr_sources)),
        usr = " ".join(makefile_usr_obj)
    shell:
        """
        function at_exit {{
            echo "include {input.makefile_usr}" >> makefile
        }}
        trap at_exit EXIT

        set +u  # Do not error on undefined bash variables
        export CC="{config[MPICC]}" FC="{config[MPIFC]}" \
            CFLAGS="{config[CFLAGS]}" FFLAGS="{config[FFLAGS]} {params.inc}" \
            USR="{params.usr}"
        source $(which makenek) {params.case} -nocompile
        """

# FIXME!
rule generate_libgs:
    input:
        'makefile'
    output:
        temp(SOURCE_ROOT + "/3rd_party/gslib/gslib-1.0.1/src/libgs.a"),
        libgs = SOURCE_ROOT + "/3rd_party/gslib/lib/libgs.a"
    params:
        case = f'{CASE}',
    shell:
        """
        set +u
        source $(which makenek) {params.case} -nocompile
        export NOCOMPILE=0
        rmdir $(dirname {output.libgs})
        make_3rd_party
        """

# generate sessionfile
rule generate_session:
    output:
        "SESSION.NAME"
    params:
        case = f"{CASE}"
    shell:
        """
        touch SESSION.NAME
        echo {params.case} > SESSION.NAME
        echo `pwd`'/' >>  SESSION.NAME
        """
