from glob import glob
import os
from pathlib import Path
from eturb.util import modification_date, now, activate_paths

configfile: "../../Snakeconfig.yml"

# Wildcard
CASES = glob_wildcards('{case}.usr').case


def tar_name():
    return 'archive-{timestamp}.tar.gz'.format(
            timestamp=max(
                modification_date(f) for f in ('compiler.out', 'SESSION.NAME')
            )
    )

subworkflow Nek5000:
    workdir:
        "../../lib/Nek5000"
    snakefile:
        "../../lib/Nek5000/Snakefile"
    configfile:
        "../../Snakeconfig.yml"

# default rule
rule all:
    input:
        'nek5000'

# shorthand for mesh
rule mesh:
    input:
        expand('{case}.re2', case=CASES),
        expand('{case}.ma2', case=CASES)

# compile
rule compile:
    input:
        expand('{case}.re2', case=CASES),
        expand('{case}.ma2', case=CASES)
    output:
        # temp('makefile'),
        'makefile',
        expand('{case}.f', case=CASES),
        'compiler.out',
        'nek5000'
    shell:
        'CC="{config[MPICC]}" FC="{config[MPIFC]}" CFLAGS="{config[CFLAGS]}" FFLAGS="{config[FFLAGS]}" '
        'makenek'

# run
rule run:
    input:
        'nek5000'
    log:
        "logs/run_" + now() + ".log"
    params:
        nproc = str(os.cpu_count()),
        case = expand("{case}", case=CASES)
    shell:
        """
        touch SESSION.NAME
        echo {params.case} > SESSION.NAME
        echo `pwd`'/' >>  SESSION.NAME
        {config[MPIEXEC]} -np {params.nproc} ./nek5000 > {log} &
        ln -sf {log} {params.case}.log
        """

# clean compiler output
rule clean:
    input: 'makefile',
    shell: 'echo "N" | makenek clean'

# clean simulation files
rule cleansimul:
    params:
        field_files = expand('*{case}?.f?????', case=CASES),
        case = expand('{case}', case=CASES),
        tarball = tar_name()
    shell:
        """
        if [ ! -f {params.tarball} ]; then
            echo "ERROR: Archive {params.tarball} not found. Refusing to clean simulation files! Run 'snakemake archive'"
            exit 1
        fi
        set +e
        _remove() {{
            echo -e "Removing $@ ..."
            rm -Ifv $@
        }}
        _remove {params.case}.{{re2,ma2,log,f,nek5000}}
        _remove makefile box.tmp compiler.out SESSION.NAME GIT_REVISION.txt nek5000
        _remove -r obj
        _remove {params.field_files}
        exit 0
        """

# clean everything
rule cleanall:
    shell:
        """
        snakemake clean cleansimul
        """

# create an archive with all of our results
# requires pigz - parallelized gzip
#  ["{dataset}/a.txt".format(dataset=dataset) for dataset in DATASETS]
rule archive:
    input:
        [glob(f'{case}0.f*') for case in CASES],
        [glob(f'vgr{case}0.f*') for case in CASES],
        expand('{case}.usr', case=CASES),
        expand('{case}.par', case=CASES),
        expand('{case}.re2', case=CASES),
        expand('{case}.ma2', case=CASES),
        'SIZE',
        'compiler.out',
        'SESSION.NAME',
        'GIT_REVISION.txt'
    output:
        tarball=tar_name()
    shell:
        """
        tar --use-compress-program=pigz -cvf {output.tarball} {input}
        rm -f GIT_REVISION.txt
        """


# internal rules
# ==============
# generate a box mesh
rule generate_box:
    input:
        Nek5000('bin/genbox'),
        box=expand('{case}.box', case=CASES)
    output:
        'box.re2'
    shell:
        'echo {input.box} | '
        'genbox'

# rename mesh file re2
rule move_box:
    input: 'box.re2'
    output: expand('{case}.re2', case=CASES)
    shell:
        'mv -f {input} {output}'

# generate map / connectivity matrix
rule generate_map:
    input:
        Nek5000('bin/genmap'),
        expand('{case}.re2', case=CASES)
    output:
        expand('{case}.ma2', case=CASES)
    params:
        prefix = expand('{case}', case=CASES),
        tolerance = 0.01
    shell:
        'echo "{params.prefix}\n{params.tolerance}" | '
        'genmap'

# record git revision
rule git_rev:
    output: 'GIT_REVISION.txt'
    version: subprocess.getoutput('git rev-parse --short HEAD')
    shell:
        'printf {version} > GIT_REVISION.txt'
