import os
from glob import glob
from pathlib import Path
from socket import gethostname

from abl import (
    get_configfile,
    get_root,
    makefile_usr_sources,
    makefile_usr_obj,
    Output
)
from eturb.util import modification_date, now, activate_paths


CONFIG = get_configfile()
ROOT = get_root()

# TODO: define configuration files for SNIC clusters
configfile: CONFIG

# Wildcard
CASES = glob_wildcards('{case}.usr').case


def tar_name():
    timestamp = max(
        modification_date(f) for f in ('compiler.out', 'SESSION.NAME')
    )
    return f'archive-{timestamp}.tar.gz' if timestamp else ""


subworkflow Nek5000:
    workdir:
        os.getenv("SOURCE_ROOT", ROOT / "../../lib/Nek5000")
    snakefile:
        os.getenv("SOURCE_ROOT", str(ROOT / "../../lib/Nek5000")) + "/Snakefile"
    configfile:
        CONFIG

# default rule
rule all:
    input:
        'nek5000'

# shorthand for mesh
rule mesh:
    input:
        expand('{case}.re2', case=CASES),
        expand('{case}.ma2', case=CASES)

# compile
rule compile:
    input:
        'makefile'
    output:
        expand('{case}.f', case=CASES),
        exe='nek5000'
    shell:
        'make {output.exe}'

# run
rule run:
    input:
        'nek5000'
    log:
        "logs/run_" + now() + ".log"
    params:
        nproc = str(os.cpu_count()),
        case = expand("{case}", case=CASES)
    shell:
        """
        touch SESSION.NAME
        echo {params.case} > SESSION.NAME
        echo `pwd`'/' >>  SESSION.NAME
        {config[MPIEXEC]} -np {params.nproc} ./nek5000 > {log} &
        ln -sf {log} {params.case}.log
        echo "Log file: $PWD"/{params.case}.log
        """

# clean compiler output
rule clean:
    params:
        case = expand('{case}', case=CASES),
    shell:
        """
        echo "cleaning Nek5000 ..."
        rm -fv {params.case}.f nek5000
        rm -rf obj makefile_usr.inc
        rm -fv $SOURCE_ROOT/core/mpif.h
        """

# clean simulation files
rule cleansimul:
    params:
        field_files = expand('*{case}?.f?????', case=CASES),
        case = expand('{case}', case=CASES),
        tarball = tar_name()
    shell:
        """
        if [ "{params.tarball}" ] && [  ! -f "{params.tarball}" ]; then
            echo "ERROR: Archive {params.tarball} not found. Refusing to clean simulation files! Run 'snakemake archive'"
            exit 1
        fi
        set +e
        _remove() {{
            echo -e "Removing $@ ..."
            rm -Ifv $@
        }}
        _remove {params.case}.{{re2,ma2,log,f,nek5000}}
        _remove makefile box.tmp compiler.out SESSION.NAME GIT_REVISION.txt nek5000
        _remove -r obj
        _remove {params.field_files}
        exit 0
        """

# clean everything
rule cleanall:
    shell:
        """
        snakemake clean cleansimul
        """

# create an archive with all of our results
# requires pigz - parallelized gzip
#  ["{dataset}/a.txt".format(dataset=dataset) for dataset in DATASETS]
rule archive:
    input:
        [glob(f'{case}0.f*') for case in CASES],
        [glob(f'vgr{case}0.f*') for case in CASES],
        expand('{case}.usr', case=CASES),
        expand('{case}.par', case=CASES),
        expand('{case}.re2', case=CASES),
        expand('{case}.ma2', case=CASES),
        'SIZE',
        'SESSION.NAME',
        'GIT_REVISION.txt'
    output:
        tarball=tar_name()
    shell:
        """
        tar --use-compress-program=pigz -cvf {output.tarball} {input}
        rm -f GIT_REVISION.txt
        """


# internal rules
# ==============
# generate a box mesh
rule generate_box:
    input:
        Nek5000('bin/genbox'),
        box=expand('{case}.box', case=CASES)
    output:
        'box.re2'
    shell:
        'echo {input.box} | '
        'genbox'

# rename mesh file re2
rule move_box:
    input: 'box.re2'
    output: expand('{case}.re2', case=CASES)
    shell:
        'mv -f {input} {output}'

# generate map / connectivity matrix
rule generate_map:
    input:
        Nek5000('bin/genmap'),
        expand('{case}.re2', case=CASES)
    output:
        expand('{case}.ma2', case=CASES)
    params:
        prefix = expand('{case}', case=CASES),
        tolerance = 0.01
    shell:
        'echo "{params.prefix}\n{params.tolerance}" | '
        'genmap'

# generate makefile_usr.inc
rule generate_makefile_usr:
    input:
        "templates/makefile_usr.inc.j2"
    output:
        "makefile_usr.inc"
    run:
        o = Output()
        with open(str(output), "w") as fp:
            o.write_makefile_usr(fp=fp)

# generate makefile
rule generate_makefile:
    input:
        expand('{case}.re2', case=CASES),
        expand('{case}.ma2', case=CASES),
        expand('{case}.usr', case=CASES),
        makefile_usr = "makefile_usr.inc"
    output:
        # temp('makefile'),
        'makefile',
    params:
        case = expand('{case}', case=CASES),
        inc = " ".join((f"-I{inc_dir}" for inc_dir in makefile_usr_sources)),
        usr = " ".join(makefile_usr_obj)
    shell:
        """
        CC="{config[MPICC]}" FC="{config[MPIFC]}" \
            CFLAGS="{config[CFLAGS]}" FFLAGS="{config[FFLAGS]} {params.inc}" \
            USR="{params.usr}" \
            makenek {params.case} -nocompile
        echo "include {input.makefile_usr}" >> makefile
        """

# record git revision
rule git_rev:
    output: 'GIT_REVISION.txt'
    shell: 'git rev-parse --short HEAD > GIT_REVISION.txt'
